@use "sass:color";
@use "sass:map";
@use "../animation/functions" as functions2;
@use "../animation/variables" as variables2;
@use "../base/mixins" as base-mixins;
@use "../feature-targeting/functions" as feature-targeting-functions;
@use "../feature-targeting/mixins" as feature-targeting-mixins;
@use "../theme/mixins" as theme-mixins;
@use "./functions";
@use "./keyframes";
@use "./variables";
@use "../theme/variables" as theme-variables;
@mixin core-styles($query: feature-targeting-functions.all()) {
  $feat-structure: feature-targeting-functions.create-target($query, structure);
  .mdc-ripple-surface {
    @include surface($query: $query);
    @include states($query: $query);
    @include radius-bounded($query: $query);
    @include feature-targeting-mixins.targets($feat-structure) {
      position: relative;
      outline: none;
      overflow: hidden;
    }
    &[data-mdc-ripple-is-unbounded] {
      @include radius-unbounded($query: $query);
      @include feature-targeting-mixins.targets($feat-structure) {
        overflow: visible;
      }
    }
    &--primary {
      @include states(primary, $query: $query);
    }
    &--accent {
      @include states(secondary, $query: $query);
    }
  }
}
@mixin common($query: feature-targeting-functions.all()) {
  $feat-animation: feature-targeting-functions.create-target($query, animation);
  @include feature-targeting-mixins.targets($feat-animation) {
    @include base-mixins.emit-once("mdc-ripple/common/animation") {
      @include keyframes.keyframes_;
    }
  }
}
@mixin surface($query: feature-targeting-functions.all(), $ripple-target: "&") {
  $feat-animation: feature-targeting-functions.create-target($query, animation);
  $feat-structure: feature-targeting-functions.create-target($query, structure);
  @include feature-targeting-mixins.targets($feat-structure) {
    --mdc-ripple-fg-size: 0;
    --mdc-ripple-left: 0;
    --mdc-ripple-top: 0;
    --mdc-ripple-fg-scale: 1;
    --mdc-ripple-fg-translate-end: 0;
    --mdc-ripple-fg-translate-start: 0;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  }
  #{$ripple-target}::before,
  #{$ripple-target}::after {
    @include feature-targeting-mixins.targets($feat-structure) {
      position: absolute;
      border-radius: 50%;
      opacity: 0;
      pointer-events: none;
      content: "";
    }
  }
  #{$ripple-target}::before {
    @include feature-targeting-mixins.targets($feat-animation) {
      transition:
        opacity variables.$states-wash-duration linear,
        background-color variables.$states-wash-duration linear;
    }
    @include feature-targeting-mixins.targets($feat-structure) {
    }
  }
  &.mdc-ripple-upgraded {
    #{$ripple-target}::before {
      @include feature-targeting-mixins.targets($feat-structure) {
        transform: scale(var(--mdc-ripple-fg-scale, 1));
      }
    }
    #{$ripple-target}::after {
      @include feature-targeting-mixins.targets($feat-structure) {
        top: 0;
        left: 0;
        transform: scale(0);
        transform-origin: center center;
      }
    }
  }
  &.mdc-ripple-upgraded--unbounded {
    #{$ripple-target}::after {
      @include feature-targeting-mixins.targets($feat-structure) {
        top: var(--mdc-ripple-top, 0);
        left: var(--mdc-ripple-left, 0);
      }
    }
  }
  &.mdc-ripple-upgraded--foreground-activation {
    #{$ripple-target}::after {
      @include feature-targeting-mixins.targets($feat-animation) {
        animation:
          mdc-ripple-fg-radius-in variables.$translate-duration forwards,
          mdc-ripple-fg-opacity-in variables.$fade-in-duration forwards;
      }
    }
  }
  &.mdc-ripple-upgraded--foreground-deactivation {
    #{$ripple-target}::after {
      @include feature-targeting-mixins.targets($feat-animation) {
        animation: mdc-ripple-fg-opacity-out variables.$fade-out-duration;
      }
      @include feature-targeting-mixins.targets($feat-structure) {
        transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));
      }
    }
  }
}
@mixin states-base-color(
  $color, $query: feature-targeting-functions.all(), $ripple-target: "&") {
  $feat-color: feature-targeting-functions.create-target($query, color);
  #{$ripple-target}::before,
  #{$ripple-target}::after {
    @include feature-targeting-mixins.targets($feat-color) {
      @if color.alpha(theme-variables.prop-value($color)) > 0 {
        @include theme-mixins.prop(background-color, $color);
      } @else {
        content: none;
      }
    }
  }
}
@mixin states-opacities($opacity-map: (), $has-nested-focusable-element: false, $ripple-target: "&", $query: feature-targeting-functions.all()) {
  @if map.has-key($opacity-map, hover) {
    @include states-hover-opacity(map.get($opacity-map, hover), $ripple-target: $ripple-target, $query: $query);
  }
  @if map.has-key($opacity-map, focus) {
    @include states-focus-opacity(map.get($opacity-map, focus), $ripple-target: $ripple-target, $has-nested-focusable-element: $has-nested-focusable-element, $query: $query);
  }
  @if map.has-key($opacity-map, press) {
    @include states-press-opacity(map.get($opacity-map, press), $ripple-target: $ripple-target, $query: $query);
  }
}
@mixin states-hover-opacity(
  $opacity, $query: feature-targeting-functions.all(), $ripple-target: "&") {
  $feat-color: feature-targeting-functions.create-target($query, color);
  &:hover {
    #{$ripple-target}::before {
      @include feature-targeting-mixins.targets($feat-color) {
        opacity: $opacity;
      }
    }
  }
}
@mixin states-focus-opacity(
  $opacity,
  $has-nested-focusable-element: false,
  $query: feature-targeting-functions.all(),
  $ripple-target: "&") {
  @if $has-nested-focusable-element {
    &.mdc-ripple-upgraded--background-focused,
    &.mdc-ripple-upgraded:focus-within,
    &:not(.mdc-ripple-upgraded):focus,
    &:not(.mdc-ripple-upgraded):focus-within {
      #{$ripple-target}::before {
        @include states-focus-opacity-properties_(
          $opacity: $opacity, $query: $query);
      }
    }
  } @else {
    &.mdc-ripple-upgraded--background-focused,
    &:not(.mdc-ripple-upgraded):focus {
      #{$ripple-target}::before {
        @include states-focus-opacity-properties_(
          $opacity: $opacity, $query: $query);
      }
    }
  }
}
@mixin states-focus-opacity-properties_($opacity, $query) {
  $feat-animation: feature-targeting-functions.create-target($query, animation);
  $feat-color: feature-targeting-functions.create-target($query, color);
  @include feature-targeting-mixins.targets($feat-animation) {
    transition-duration: 75ms;
  }
  @include feature-targeting-mixins.targets($feat-color) {
    opacity: $opacity;
  }
}
@mixin states-press-opacity($opacity, $query: feature-targeting-functions.all(), $ripple-target: "&") {
  $feat-animation: feature-targeting-functions.create-target($query, animation);
  $feat-color: feature-targeting-functions.create-target($query, color);
  &:not(.mdc-ripple-upgraded) {
    #{$ripple-target}::after {
      @include feature-targeting-mixins.targets($feat-animation) {
        transition: opacity variables.$fade-out-duration linear;
      }
    }
    &:active {
      #{$ripple-target}::after {
        @include feature-targeting-mixins.targets($feat-animation) {
          transition-duration: variables.$fade-in-duration;
        }
        @include feature-targeting-mixins.targets($feat-color) {
          opacity: $opacity;
        }
      }
    }
  }
  &.mdc-ripple-upgraded {
    @include feature-targeting-mixins.targets($feat-color) {
      --mdc-ripple-fg-opacity: #{$opacity};
    }
  }
}
@mixin states(
  $color: theme-variables.prop-value(on-surface),
  $has-nested-focusable-element: false,
  $query: feature-targeting-functions.all(),
  $ripple-target: "&",
) {
  @include states-interactions_(
    $color: $color,
    $has-nested-focusable-element: $has-nested-focusable-element,
    $query: $query,
    $ripple-target: $ripple-target);
}
@mixin states-activated(
  $color, $has-nested-focusable-element: false, $query: feature-targeting-functions.all(), $ripple-target: "&") {
  $feat-color: feature-targeting-functions.create-target($query, color);
  $activated-opacity: functions.states-opacity($color, activated);
  &--activated {
    #{$ripple-target}::before {
      @include feature-targeting-mixins.targets($feat-color) {
        opacity: $activated-opacity;
      }
    }
    @include states-interactions_(
      $color: $color,
      $has-nested-focusable-element: $has-nested-focusable-element,
      $opacity-modifier: $activated-opacity,
      $query: $query,
      $ripple-target: $ripple-target);
  }
}
@mixin states-selected(
  $color,
  $has-nested-focusable-element: false,
  $query: feature-targeting-functions.all(),
  $ripple-target: "&") {
  $feat-color: feature-targeting-functions.create-target($query, color);
  $selected-opacity: functions.states-opacity($color, selected);
  &--selected {
    #{$ripple-target}::before {
      @include feature-targeting-mixins.targets($feat-color) {
        opacity: $selected-opacity;
      }
    }
    @include states-interactions_(
      $color: $color,
      $has-nested-focusable-element: $has-nested-focusable-element,
      $opacity-modifier: $selected-opacity,
      $query: $query,
      $ripple-target: $ripple-target);
  }
}
@mixin radius-bounded(
  $radius: 100%, $query: feature-targeting-functions.all(), $ripple-target: "&") {
  $feat-struture: feature-targeting-functions.create-target($query, structure);
  #{$ripple-target}::before,
  #{$ripple-target}::after {
    @include feature-targeting-mixins.targets($feat-struture) {
      top: calc(50% - #{$radius});
      left: calc(50% - #{$radius});
      width: $radius * 2;
      height: $radius * 2;
    }
  }
  &.mdc-ripple-upgraded {
    #{$ripple-target}::after {
      @include feature-targeting-mixins.targets($feat-struture) {
        width: var(--mdc-ripple-fg-size, $radius);
        height: var(--mdc-ripple-fg-size, $radius);
      }
    }
  }
}
@mixin radius-unbounded(
  $radius: 100%, $query: feature-targeting-functions.all(), $ripple-target: "&") {
  $feat-struture: feature-targeting-functions.create-target($query, structure);
  #{$ripple-target}::before,
  #{$ripple-target}::after {
    @include feature-targeting-mixins.targets($feat-struture) {
      top: calc(50% - #{$radius / 2});
      left: calc(50% - #{$radius / 2});
      width: $radius;
      height: $radius;
    }
  }
  &.mdc-ripple-upgraded {
    #{$ripple-target}::before,
    #{$ripple-target}::after {
      @include feature-targeting-mixins.targets($feat-struture) {
        top: var(--mdc-ripple-top, calc(50% - #{$radius / 2}));
        left: var(--mdc-ripple-left, calc(50% - #{$radius / 2}));
        width: var(--mdc-ripple-fg-size, $radius);
        height: var(--mdc-ripple-fg-size, $radius);
      }
    }
    #{$ripple-target}::after {
      @include feature-targeting-mixins.targets($feat-struture) {
        width: var(--mdc-ripple-fg-size, $radius);
        height: var(--mdc-ripple-fg-size, $radius);
      }
    }
  }
}
@mixin states-interactions_(
  $color,
  $has-nested-focusable-element,
  $opacity-modifier: 0,
  $query: feature-targeting-functions.all(),
  $ripple-target: "&",
) {
  @include target-selector($ripple-target) {
    @include states-base-color($color, $query);
  }
  $opacity-map: (
    hover: functions.states-opacity($color, hover) + $opacity-modifier,
    focus: functions.states-opacity($color, focus) + $opacity-modifier,
    press: functions.states-opacity($color, press) + $opacity-modifier,
  );
  @include states-opacities($opacity-map, $has-nested-focusable-element: $has-nested-focusable-element, $ripple-target: $ripple-target, $query: $query);
}
@mixin target-selector($ripple-target: "&") {
  @if $ripple-target == "&" {
    @content;
  } @else {
    #{$ripple-target} {
      @content;
    }
  }
}
@mixin target-common($query: feature-targeting-functions.all()) {
  $feat-structure: feature-targeting-functions.create-target($query, structure);
  @include feature-targeting-mixins.targets($feat-structure) {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
}
